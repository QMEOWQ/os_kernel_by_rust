1. 栈溢出原理

- guard page 是一类位于栈底部的特殊内存页，所以如果发生了栈溢出，最典型的现象就是访问这里。这类内存页不会映射到物理内存中，所以访问这里只会造成 page fault 异常，而不会污染其他内存。bootloader 已经为我们的内核栈设置好了一个 guard page，所以栈溢出会导致 page fault 异常。

- 当 page fault 发生时，CPU 会在 IDT 寻找对应的处理函数，并尝试将 中断栈帧 入栈，但此时栈指针指向了一个实际上并不存在的 guard page，然后第二个 page fault 异常就被触发了，根据 AMD64 手册，double fault 也随之被触发了。

- 这时，CPU 会尝试调用 double fault 对应的处理函数，然而 CPU 依然会试图将错误栈帧入栈，由于栈指针依然指向 guard page，于是 第三次 page fault 发生了，最终导致 triple fault 异常的抛出，系统因此重启。所以仅仅是注册错误处理函数并不能在此种情况下阻止 triple fault 的发生。

- 为了解决栈溢出问题，x86_64 架构允许在异常发生时，将栈切换为一个预定义的完好栈，这个切换是执行在硬件层次的，所以完全可以在 CPU 将异常栈帧入栈之前执行。

- 这个切换机制是由 中断栈表 （IST）实现的，IST 是一个由 7 个确认可用的完好栈的指针组成。

- 对于每一个错误处理函数，我们都可以通过对应的 IDT 条目中的 stack_pointers 条目指定 IST 中的一个栈。比如我们可以让 double fault 对应的处理函数使用 IST 中的第一个栈指针，则 CPU 会在这个异常发生时，自动将栈切换为该栈。该切换行为会在所有入栈操作之前进行，由此可以避免进一步触发 triple fault 异常。

2. 尾调用优化(tail recursion optimizations)

- 这个优化最主要的影响就是会让编辑器将最后一行是递归语句的函数转化为普通的循环。由于没有通过递归创建新的栈帧，所以栈自然也不会出问题。

